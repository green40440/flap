<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flappy Bird â€” Global Leaderboard</title>
<style>
/* ... (All your CSS code here) ... */
:root {
--bg:#87CEEB;
--ground:#DEB887;
/* ... (rest of CSS) ... */
</style>
</head>
<body>
<div id="gameWrap">
</div>

<div id="leaderboardModal" class="modal" style="display:none;">
</div>

<script>
// ================= CONFIG =================
const CONFIG = {
canvasWidth:720,canvasHeight:540,gravity:1100,flapImpulse:-340,
// DYNAMIC GAP CONFIGURATION
pipeGapMax: 150, // Starting and max gap size
pipeGapMin: 75, // Smallest gap size (half of max)
gapScaleRate: 0.8, // How many pixels the gap shrinks per point
minGapStreak: 3, // How many minimum-gap pipes spawn in a row
// END DYNAMIC GAP CONFIGURATION
pipeWidth: 64,pipeSpacing:220,pipeSpeed:200,
spawnOffset:120,groundHeight:80,birdRadius:16,pipeMinY:80,pipeMaxYOffset:200,flapCooldownMs:80,soundVolume:0.15
};
const LEADERBOARD_SERVER = "https://your-flappy-leaderboard.example.com"; // replace with your hosted server

// ================= CANVAS =================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
const containerWidth = Math.min(820,window.innerWidth*0.98);
const scale = containerWidth/CONFIG.canvasWidth;
const logicalW = CONFIG.canvasWidth, logicalH=CONFIG.canvasHeight, dpr=window.devicePixelRatio||1;
canvas.style.width=Math.round(logicalW*scale)+'px';
canvas.style.height=Math.round(logicalH*scale)+'px';
canvas.width=Math.round(logicalW*dpr*scale);
canvas.height=Math.round(logicalH*dpr*scale);
ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// ================= GAME STATE =================
let state='menu',score=0,best=parseInt(localStorage.getItem('flappy_best')||'0',10);
const scoreEl=document.getElementById('score'),bestEl=document.getElementById('best');
const overlay=document.getElementById('overlay'),menuEl=document.getElementById('menu');
const startBtn=document.getElementById('startBtn'),muteBtn=document.getElementById('muteBtn'),pauseBtn=document.getElementById('pauseBtn'),resetBtn=document.getElementById('resetBtn');
const leaderboardBtn=document.getElementById('leaderboardBtn');
const leaderboardModal=document.getElementById('leaderboardModal');
const leaderboardList=document.getElementById('leaderboardList');
const refreshLbBtn=document.getElementById('refreshLb'),closeLb=document.getElementById('closeLb'),closeBtn=document.getElementById('closeBtn');

bestEl.textContent=best;

const bird={x:CONFIG.canvasWidth*0.28,y:CONFIG.canvasHeight/2,vy:0,radius:CONFIG.birdRadius,rotation:0};
let pipes=[],lastSpawnX=0,lastTime=null,flapCooldown=0,audioCtx=null;
// DYNAMIC GAP STATE
let currentPipeGap = CONFIG.pipeGapMax;
let minGapCounter = 0;

// ================= AUDIO =================
let muted=false;
function ensureAudio(){if(!audioCtx)audioCtx=new (window.AudioContext||window.webkitAudioContext)();}
function playBeep(f=440,d=0.06,t='sine'){
Â  Â  if(muted)return;
Â  Â  ensureAudio();
Â  Â  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
Â  Â  o.type=t;o.frequency.value=f;g.gain.value=CONFIG.soundVolume;
Â  Â  o.connect(g);g.connect(audioCtx.destination);
Â  Â  const now=audioCtx.currentTime;
Â  Â  o.start(now);
Â  Â  g.gain.setValueAtTime(CONFIG.soundVolume,now);
Â  Â  g.gain.exponentialRampToValueAtTime(0.0001,now+d);
Â  Â  o.stop(now+d);
}
function playFlap(){playBeep(650,0.05,'square');}
function playScore(){playBeep(880,0.08,'triangle');}
function playHit(){playBeep(200,0.3,'sawtooth');}

// Mute button handler
muteBtn.addEventListener('click',()=>{
Â  Â  muted=!muted;
Â  Â  muteBtn.textContent=muted?'ğŸ”‡':'ğŸ”Š';
});

// ================= GAME LOGIC =================
function resetGame(){
Â  Â  score=0;
Â  Â  scoreEl.textContent=0;
Â  Â  bird.y=CONFIG.canvasHeight/2;
Â  Â  bird.vy=0;
Â  Â  bird.rotation=0;
Â  Â  pipes=[];
Â  Â  lastSpawnX=0;
Â  Â  currentPipeGap=CONFIG.pipeGapMax;
Â  Â  minGapCounter=0;
Â  Â  state='menu';
    // When game over, update menu content to show score and 'Play Again'
Â  Â  overlay.style.display='block';
Â  Â  menuEl.innerHTML=`<h1>Flappy â€” Game Over!</h1><div>Score: <strong>${bestEl.textContent}</strong></div><div style="margin-top:12px;"><button id="startBtn" class="button">Play Again</button></div><div style="margin-top:8px;" class="footer">Made with ğŸ’› â€” single-file HTML</div>`;
Â  Â  document.getElementById('startBtn').addEventListener('click',startGame);
    draw(); // Draw final state
}

function startGame(){
Â  Â  state='playing';
Â  Â  overlay.style.display='none';
Â  Â  lastTime=null;
Â  Â  pipes=[];
Â  Â  lastSpawnX=0;
Â  Â  bird.y=CONFIG.canvasHeight/2;
Â  Â  bird.vy=0;
Â  Â  bird.rotation=0;
Â  Â  currentPipeGap=CONFIG.pipeGapMax;
Â  Â  minGapCounter=0;
Â  Â  requestAnimationFrame(gameLoop);
Â  Â  playFlap();
}

function flap(){
Â  Â  if(state==='playing' && Date.now()>flapCooldown){
Â  Â  Â  Â  bird.vy=CONFIG.flapImpulse;
Â  Â  Â  Â  flapCooldown=Date.now()+CONFIG.flapCooldownMs;
Â  Â  Â  Â  playFlap();
Â  Â  }
}

// Input handling
document.getElementById('startBtn').addEventListener('click',startGame);
resetBtn.addEventListener('click',resetGame);
pauseBtn.addEventListener('click',()=>{
Â  Â  if(state==='playing'){
Â  Â  Â  Â  state='paused';
Â  Â  Â  Â  pauseBtn.textContent='â–¶ï¸';
Â  Â  Â  Â  overlay.style.display='block';
Â  Â  Â  Â  menuEl.innerHTML=`<h1>Paused</h1><div style="margin-top:12px;"><button id="resumeBtn" class="button">Resume</button></div>`;
Â  Â  Â  Â  document.getElementById('resumeBtn').addEventListener('click',()=>{
Â  Â  Â  Â  Â  Â  state='playing';
Â  Â  Â  Â  Â  Â  pauseBtn.textContent='â¸ï¸';
Â  Â  Â  Â  Â  Â  overlay.style.display='none';
Â  Â  Â  Â  Â  Â  lastTime=null; // Reset lastTime to prevent huge jump on resume
Â  Â  Â  Â  Â  Â  requestAnimationFrame(gameLoop);
Â  Â  Â  Â  });
Â  Â  } else if(state==='paused'){
Â  Â  Â  Â  state='playing';
Â  Â  Â  Â  pauseBtn.textContent='â¸ï¸';
Â  Â  Â  Â  overlay.style.display='none';
Â  Â  Â  Â  lastTime=null;
Â  Â  Â  Â  requestAnimationFrame(gameLoop);
Â  Â  }
});
window.addEventListener('keydown',(e)=>{
Â  Â  if(e.code==='Space' || e.key===' '){e.preventDefault();flap();}
});
canvas.addEventListener('mousedown',flap);
canvas.addEventListener('touchstart',flap);

function spawnPipe(){
Â  Â  let gapSize;
Â  Â Â 
Â  Â  // Dynamic gap logic: Shrink gap based on score, but enforce minimum streak
Â  Â  const targetGap = Math.max(CONFIG.pipeGapMin, CONFIG.pipeGapMax - score * CONFIG.gapScaleRate);

Â  Â  if (targetGap === CONFIG.pipeGapMin) {
Â  Â  Â  Â  if (minGapCounter < CONFIG.minGapStreak) {
Â  Â  Â  Â  Â  Â  gapSize = CONFIG.pipeGapMin;
Â  Â  Â  Â  Â  Â  minGapCounter++;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // After the streak, randomize, then reset counter next time
Â  Â  Â  Â  Â  Â  gapSize = CONFIG.pipeGapMin + Math.random() * (CONFIG.pipeGapMax - CONFIG.pipeGapMin);
Â  Â  Â  Â  Â  Â  minGapCounter = 0;Â 
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  // Gap is still shrinking, choose between target and max
Â  Â  Â  Â  gapSize = targetGap + Math.random() * (CONFIG.pipeGapMax - targetGap);
Â  Â  Â  Â  minGapCounter = 0;
Â  Â  }
Â  Â Â 
Â  Â  currentPipeGap = gapSize;
Â  Â Â 
Â  Â  // Determine the center of the gap (random Y position)
Â  Â  const minY = CONFIG.pipeMinY + gapSize/2;
Â  Â  const maxY = CONFIG.canvasHeight - CONFIG.groundHeight - CONFIG.pipeMaxYOffset - gapSize/2;
Â  Â  const center = minY + Math.random()*(maxY-minY);

Â  Â  const pipe = {
Â  Â  Â  Â  x: CONFIG.canvasWidth + CONFIG.spawnOffset,
Â  Â  Â  Â  topHeight: center - gapSize/2,
Â  Â  Â  Â  bottomY: center + gapSize/2,
Â  Â  Â  Â  width: CONFIG.pipeWidth,
Â  Â  Â  Â  gap: gapSize,
Â  Â  Â  Â  scored: false
Â  Â  };
Â  Â  pipes.push(pipe);
Â  Â  lastSpawnX=pipe.x;
}

function checkCollision(pipe){
Â  Â  // 1. Check Top Pipe Collision
Â  Â  if(bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipe.width){
Â  Â  Â  Â  if(bird.y - bird.radius < pipe.topHeight){return true;}
Â  Â  }

Â  Â  // 2. Check Bottom Pipe Collision
Â  Â  if(bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipe.width){
Â  Â  Â  Â  if(bird.y + bird.radius > pipe.bottomY){return true;}
Â  Â  }
Â  Â Â 
Â  Â  // 3. Check Ground Collision
Â  Â  if(bird.y + bird.radius > CONFIG.canvasHeight - CONFIG.groundHeight){return true;}
Â  Â Â 
Â  Â  // 4. Check Ceiling Collision
Â  Â  if(bird.y - bird.radius < 0){return true;}

Â  Â  return false;
}

function updateGame(dt){
Â  Â  // Update Bird Physics
Â  Â  bird.vy+=CONFIG.gravity*dt;
Â  Â  bird.y+=bird.vy*dt;

Â  Â  // Update Bird Rotation (max 45 degrees down, 20 degrees up)
Â  Â  const maxRot = Math.PI/4;
Â  Â  const maxUpRot = -Math.PI/9;
Â  Â  bird.rotation = Math.min(maxRot, Math.max(maxUpRot, bird.vy * 0.001));

Â  Â  // Move and Spawn Pipes
Â  Â  const pipeDistance = CONFIG.pipeSpacing + CONFIG.pipeWidth;
Â  Â  if(CONFIG.canvasWidth-lastSpawnX > pipeDistance){
Â  Â  Â  Â  spawnPipe();
Â  Â  }

Â  Â  for(let i=pipes.length-1;i>=0;i--){
Â  Â  Â  Â  const pipe=pipes[i];
Â  Â  Â  Â  pipe.x-=CONFIG.pipeSpeed*dt;

Â  Â  Â  Â  // Check Score
Â  Â  Â  Â  if(!pipe.scored && pipe.x + pipe.width < bird.x - bird.radius){
Â  Â  Â  Â  Â  Â  pipe.scored=true;
Â  Â  Â  Â  Â  Â  score++;
Â  Â  Â  Â  Â  Â  scoreEl.textContent=score;
Â  Â  Â  Â  Â  Â  if(score>best){
Â  Â  Â  Â  Â  Â  Â  Â  best=score;
Â  Â  Â  Â  Â  Â  Â  Â  bestEl.textContent=best;
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.setItem('flappy_best',best);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  playScore();
Â  Â  Â  Â  }

Â  Â  Â  Â  // Check Collision
Â  Â  Â  Â  if(checkCollision(pipe)){
Â  Â  Â  Â  Â  Â  state='dead';
Â  Â  Â  Â  Â  Â  playHit();
Â  Â  Â  Â  Â  Â  resetGame();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Remove off-screen pipes
Â  Â  Â  Â  if(pipe.x+pipe.width < 0){
Â  Â  Â  Â  Â  Â  pipes.splice(i,1);
Â  Â  Â  Â  }
Â  Â  }
}

// ================= DRAWING =================
function drawGround(){
Â  Â  const y=CONFIG.canvasHeight-CONFIG.groundHeight;
Â  Â  ctx.fillStyle='var(--ground)';
Â  Â  ctx.fillRect(0,y,CONFIG.canvasWidth,CONFIG.groundHeight);
Â  Â Â 
Â  Â  // Draw ground line
Â  Â  ctx.strokeStyle='#A0522D';
Â  Â  ctx.lineWidth=4;
Â  Â  ctx.beginPath();
Â  Â  ctx.moveTo(0,y);
Â  Â  ctx.lineTo(CONFIG.canvasWidth,y);
Â  Â  ctx.stroke();
}

function drawPipe(pipe){
Â  Â  ctx.fillStyle='var(--pipe)';
Â  Â  // Top Pipe
Â  Â  ctx.fillRect(pipe.x,0,pipe.width,pipe.topHeight);
Â  Â  // Bottom Pipe
Â  Â  const bottomHeight=CONFIG.canvasHeight-CONFIG.groundHeight-pipe.bottomY;
Â  Â  ctx.fillRect(pipe.x,pipe.bottomY,pipe.width,bottomHeight);
Â  Â Â 
Â  Â  // Pipe outlines/caps
Â  Â  ctx.strokeStyle='#228B22';
Â  Â  ctx.lineWidth=2;
Â  Â  ctx.strokeRect(pipe.x,0,pipe.width,pipe.topHeight);
Â  Â  ctx.strokeRect(pipe.x,pipe.bottomY,pipe.width,bottomHeight);

Â  Â  // Draw Cap on Top Pipe
Â  Â  const capHeight=16;
Â  Â  ctx.fillStyle='#3CB371';
Â  Â  ctx.fillRect(pipe.x-4,pipe.topHeight-capHeight,pipe.width+8,capHeight);
Â  Â  ctx.strokeRect(pipe.x-4,pipe.topHeight-capHeight,pipe.width+8,capHeight);

Â  Â  // Draw Cap on Bottom Pipe
Â  Â  ctx.fillRect(pipe.x-4,pipe.bottomY,pipe.width+8,capHeight);
Â  Â  ctx.strokeRect(pipe.x-4,pipe.bottomY,pipe.width+8,capHeight);
}

function drawBird(){
Â  Â  ctx.save();
Â  Â  ctx.translate(bird.x,bird.y);
Â  Â  ctx.rotate(bird.rotation);
Â  Â Â 
Â  Â  // Bird Body (Simple Circle)
Â  Â  ctx.fillStyle='var(--bird)';
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(0,0,bird.radius,0,Math.PI*2);
Â  Â  ctx.fill();
Â  Â Â 
Â  Â  // Eye
Â  Â  ctx.fillStyle='white';
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(bird.radius*0.4, -bird.radius*0.4, bird.radius*0.3, 0, Math.PI*2);
Â  Â  ctx.fill();
Â  Â  ctx.fillStyle='black';
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(bird.radius*0.5, -bird.radius*0.4, bird.radius*0.1, 0, Math.PI*2);
Â  Â  ctx.fill();
Â  Â Â 
Â  Â  // Beak (Triangle)
Â  Â  ctx.fillStyle='#FF8C00';
Â  Â  ctx.beginPath();
Â  Â  ctx.moveTo(bird.radius, 0);
Â  Â  ctx.lineTo(bird.radius*1.6, -bird.radius*0.2);
Â  Â  ctx.lineTo(bird.radius*1.6, bird.radius*0.2);
Â  Â  ctx.closePath();
Â  Â  ctx.fill();

Â  Â  ctx.restore();
}

function draw(){
Â  Â  // Clear background (handled by CSS/Canvas style, but clear if needed)
Â  Â  ctx.clearRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

Â  Â  // Draw Pipes
Â  Â  pipes.forEach(drawPipe);

Â  Â  // Draw Ground
Â  Â  drawGround();

Â  Â  // Draw Bird
Â  Â  drawBird();
}

// ================= GAME LOOP =================
function gameLoop(timestamp){
Â  Â  if(state!=='playing'){
Â  Â  Â  Â  // Draw the current state once (e.g., bird on ground, but not moving)
Â  Â  Â  Â  draw();
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if(lastTime===null)lastTime=timestamp;
Â  Â  const dt=(timestamp-lastTime)/1000;
Â  Â  lastTime=timestamp;

Â  Â  updateGame(dt);
Â  Â  draw();

Â  Â  requestAnimationFrame(gameLoop);
}

// Initialize game on menu screen
resetGame();

// ================= LEADERBOARD LOGIC =================
// NOTE: The leaderboard is implemented with MOCK data for a single-file HTML environment.
function renderLeaderboard(data){
Â  Â  leaderboardList.innerHTML = ''; // Clear existing list
Â  Â  if(!data || data.length === 0){
Â  Â  Â  Â  leaderboardList.innerHTML = '<p style="text-align:center;">No scores posted yet.</p>';
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  data.sort((a,b) => b.score - a.score); // Sort by score descending

Â  Â  data.forEach((entry, index) => {
Â  Â  Â  Â  const row = document.createElement('div');
Â  Â  Â  Â  row.className = 'leaderboard-row';
Â  Â  Â  Â  const rank = index < 3 ? `ğŸ… #${index+1}` : `#${index+1}`;
Â  Â  Â  Â  row.innerHTML = `
Â  Â  Â  Â  Â  Â  <span>${rank} - ${entry.name || 'Anonymous'}</span>
Â  Â  Â  Â  Â  Â  <span>${entry.score}</span>
Â  Â  Â  Â  `;
Â  Â  Â  Â  leaderboardList.appendChild(row);
Â  Â  });
}

async function fetchLeaderboard(){
Â  Â  leaderboardList.innerHTML = '<small>Loading...</small>';
Â  Â Â 
Â  Â  // Mock Data for local testing since the server is a placeholder
Â  Â  const mockData = [
Â  Â  Â  Â  { name: "Gemini AI", score: 99 },
Â  Â  Â  Â  { name: "Player 1", score: 45 },
Â  Â  Â  Â  { name: "Newbie", score: 12 },
Â  Â  Â  Â  { name: "HighScoreFan", score: 67 },
Â  Â  Â  Â  { name: "TopFlapper", score: 78 }
Â  Â  ];
Â  Â Â 
Â  Â  setTimeout(() => { // Simulate network delay
Â  Â  Â  Â  renderLeaderboard(mockData);
Â  Â  }, 500);
}

// Modal and Button Handlers
leaderboardBtn.addEventListener('click', () => {
Â  Â  leaderboardModal.style.display = 'block';
Â  Â  fetchLeaderboard();
});

closeLb.addEventListener('click', () => {leaderboardModal.style.display = 'none';});
closeBtn.addEventListener('click', () => {leaderboardModal.style.display = 'none';});
refreshLbBtn.addEventListener('click', fetchLeaderboard);
</script>
</body>
</html>
